"""
Service Container Tests
Tests for the dependency injection container implementation.
"""

import pytest
from unittest.mock import Mock, MagicMock
from src.container import ServiceContainer, ServiceNotRegisteredError


class TestServiceContainer:
    """Test basic ServiceContainer functionality"""
    
    def setup_method(self):
        """Setup test container for each test"""
        self.container = ServiceContainer()
    
    def test_container_initialization(self):
        """Test basic container initialization"""
        assert self.container._services == {}
        assert self.container._instances == {}
        assert self.container._creating == set()
        assert self.container._config == {}
    
    def test_register_simple_service(self):
        """Test registering a service with no dependencies"""
        def simple_factory():
            return "test_service"
        
        result = self.container.register('TestService', simple_factory)
        
        # Method chaining
        assert result is self.container
        
        # Service registered
        assert 'TestService' in self.container._services
        assert self.container._services['TestService'].name == 'TestService'
        assert self.container._services['TestService'].factory == simple_factory
        assert self.container._services['TestService'].dependencies == []
        assert self.container._services['TestService'].lifecycle == ServiceLifecycle.SINGLETON
    
    def test_register_service_with_dependencies(self):
        """Test registering a service with dependencies"""
        def dependent_factory(dep1, dep2):
            return f"service_with_{dep1}_{dep2}"
        
        self.container.register('DependentService', dependent_factory, dependencies=['Dep1', 'Dep2'])
        
        service_def = self.container._services['DependentService']
        assert service_def.dependencies == ['Dep1', 'Dep2']
    
    def test_register_duplicate_service_raises_error(self):
        """Test that registering duplicate service names raises error"""
        self.container.register('TestService', lambda: "first")
        
        with pytest.raises(ValueError, match="Service 'TestService' is already registered"):
            self.container.register('TestService', lambda: "second")
    
    def test_register_invalid_factory_raises_error(self):
        """Test that non-callable factory raises error"""
        with pytest.raises(ValueError, match="Factory for 'TestService' must be callable"):
            self.container.register('TestService', "not_callable")
    
    def test_get_simple_service(self):
        """Test retrieving a simple service with no dependencies"""
        def simple_factory():
            return "test_result"
        
        self.container.register('TestService', simple_factory)
        result = self.container.get('TestService')
        
        assert result == "test_result"
    
    def test_get_service_not_found(self):
        """Test getting unregistered service raises error"""
        with pytest.raises(ServiceNotFoundError, match="Service 'NonExistent' is not registered"):
            self.container.get('NonExistent')
    
    def test_singleton_lifecycle(self):
        """Test singleton services return same instance"""
        call_count = 0
        def factory():
            nonlocal call_count
            call_count += 1
            return f"instance_{call_count}"
        
        self.container.register('SingletonService', factory, lifecycle=ServiceLifecycle.SINGLETON)
        
        result1 = self.container.get('SingletonService')
        result2 = self.container.get('SingletonService')
        
        assert result1 == result2 == "instance_1"
        assert call_count == 1  # Factory called only once
    
    def test_transient_lifecycle(self):
        """Test transient services return new instances"""
        call_count = 0
        def factory():
            nonlocal call_count
            call_count += 1
            return f"instance_{call_count}"
        
        self.container.register('TransientService', factory, lifecycle=ServiceLifecycle.TRANSIENT)
        
        result1 = self.container.get('TransientService')
        result2 = self.container.get('TransientService')
        
        assert result1 == "instance_1"
        assert result2 == "instance_2"
        assert call_count == 2  # Factory called twice
    
    def test_dependency_injection(self):
        """Test automatic dependency injection"""
        # Register dependencies
        self.container.register('Dep1', lambda: "dependency_1")
        self.container.register('Dep2', lambda: "dependency_2")
        
        # Register dependent service
        def dependent_factory(dep1, dep2):
            return f"service_with_{dep1}_and_{dep2}"
        
        self.container.register('DependentService', dependent_factory, dependencies=['Dep1', 'Dep2'])
        
        result = self.container.get('DependentService')
        assert result == "service_with_dependency_1_and_dependency_2"
    
    def test_circular_dependency_detection(self):
        """Test circular dependency detection"""
        # A depends on B, B depends on A
        self.container.register('ServiceA', lambda b: f"A_with_{b}", dependencies=['ServiceB'])
        self.container.register('ServiceB', lambda a: f"B_with_{a}", dependencies=['ServiceA'])
        
        with pytest.raises(CircularDependencyError, match="Circular dependency detected"):
            self.container.get('ServiceA')
    
    def test_external_dependency(self):
        """Test setting external dependencies"""
        external_instance = Mock()
        self.container.set_external_dependency('ExternalService', external_instance)
        
        # Register service that depends on external dependency
        def dependent_factory(ext):
            return f"service_with_{ext}"
        
        self.container.register('DependentService', dependent_factory, dependencies=['ExternalService'])
        
        result = self.container.get('DependentService')
        assert result == f"service_with_{external_instance}"
    
    def test_has_service(self):
        """Test service existence check"""
        assert not self.container.has_service('TestService')
        
        self.container.register('TestService', lambda: "test")
        assert self.container.has_service('TestService')
    
    def test_get_service_names(self):
        """Test getting list of service names"""
        assert self.container.get_service_names() == []
        
        self.container.register('Service1', lambda: "test1")
        self.container.register('Service2', lambda: "test2")
        
        names = self.container.get_service_names()
        assert set(names) == {'Service1', 'Service2'}
    
    def test_validate_dependencies(self):
        """Test dependency validation"""
        # Service with missing dependency
        self.container.register('ServiceA', lambda b: "a", dependencies=['ServiceB'])
        
        issues = self.container.validate_dependencies()
        assert 'ServiceA' in issues
        assert 'ServiceB' in issues['ServiceA']
        
        # Add missing dependency
        self.container.register('ServiceB', lambda: "b")
        issues = self.container.validate_dependencies()
        assert issues == {}
    
    def test_get_dependency_graph(self):
        """Test dependency graph generation"""
        self.container.register('ServiceA', lambda: "a")
        self.container.register('ServiceB', lambda a: "b", dependencies=['ServiceA'])
        
        graph = self.container.get_dependency_graph()
        expected = {
            'ServiceA': [],
            'ServiceB': ['ServiceA']
        }
        assert graph == expected
    
    def test_clear_container(self):
        """Test clearing container"""
        self.container.register('TestService', lambda: "test")
        self.container.set_external_dependency('External', Mock())
        self.container.set_config({'key': 'value'})
        
        # Verify container has content
        assert len(self.container._services) > 0
        assert len(self.container._config) > 0
        
        # Clear and verify empty
        result = self.container.clear()
        assert result is self.container  # Method chaining
        assert len(self.container._services) == 0
        assert len(self.container._instances) == 0
        assert len(self.container._creating) == 0
        assert len(self.container._config) == 0


class TestLLMpostorServiceConfiguration:
    """Test LLMpostor-specific service configuration"""
    
    def setup_method(self):
        """Setup test environment for LLMpostor services"""
        self.container = ServiceContainer()
    
    def test_configure_services_registers_all_services(self):
        """Test that configure_services registers all expected LLMpostor services"""
        # Mock the imports to avoid actual service dependencies
        import sys
        from unittest.mock import MagicMock
        
        # Mock the service modules
        mock_modules = {
            'src.room_manager': MagicMock(),
            'src.game_manager': MagicMock(), 
            'src.content_manager': MagicMock(),
            'src.error_handler': MagicMock(),
            'src.services.session_service': MagicMock(),
            'src.services.broadcast_service': MagicMock(),
            'src.services.auto_game_flow_service': MagicMock(),
        }
        
        # Add mocks to sys.modules
        for name, mock_module in mock_modules.items():
            sys.modules[name] = mock_module
        
        try:
            self.container.configure_services()
            
            # Verify all services are registered
            expected_services = [
                'RoomManager', 'ContentManager', 'SessionService',
                'GameManager', 'BroadcastService', 'AutoGameFlowService'
            ]
            
            registered_services = self.container.get_service_names()
            for service in expected_services:
                assert service in registered_services, f"Service {service} not registered"
            
        finally:
            # Clean up mocked modules
            for name in mock_modules:
                if name in sys.modules:
                    del sys.modules[name]
    
    def test_service_dependency_configuration(self):
        """Test that services are configured with correct dependencies"""
        # Mock the service modules
        import sys
        from unittest.mock import MagicMock
        
        mock_modules = {
            'src.room_manager': MagicMock(),
            'src.game_manager': MagicMock(),
            'src.content_manager': MagicMock(),
            'src.error_handler': MagicMock(),
            'src.services.session_service': MagicMock(),
            'src.services.broadcast_service': MagicMock(),
            'src.services.auto_game_flow_service': MagicMock(),
        }
        
        for name, mock_module in mock_modules.items():
            sys.modules[name] = mock_module
        
        try:
            self.container.configure_services()
            
            # Test specific dependency configurations
            graph = self.container.get_dependency_graph()
            
            # GameManager should depend on RoomManager
            assert 'RoomManager' in graph['GameManager']
            
            # BroadcastService should depend on multiple services
            broadcast_deps = graph['BroadcastService']
            assert 'socketio' in broadcast_deps
            assert 'RoomManager' in broadcast_deps
            assert 'GameManager' in broadcast_deps
            assert 'ErrorResponseFactory' in broadcast_deps
            
            # AutoGameFlowService should depend on multiple services
            auto_flow_deps = graph['AutoGameFlowService']
            assert 'BroadcastService' in auto_flow_deps
            assert 'GameManager' in auto_flow_deps
            assert 'RoomManager' in auto_flow_deps
            
        finally:
            # Clean up mocked modules
            for name in mock_modules:
                if name in sys.modules:
                    del sys.modules[name]


class TestConfigureContainer:
    """Test the global container configuration function"""
    
    def test_configure_container_with_socketio(self):
        """Test configure_container with socketio instance"""
        mock_socketio = Mock()
        
        # Mock the service modules to avoid import errors
        import sys
        from unittest.mock import MagicMock
        
        mock_modules = {
            'src.room_manager': MagicMock(),
            'src.game_manager': MagicMock(),
            'src.content_manager': MagicMock(),
            'src.error_handler': MagicMock(),
            'src.services.session_service': MagicMock(),
            'src.services.broadcast_service': MagicMock(),
            'src.services.auto_game_flow_service': MagicMock(),
        }
        
        for name, mock_module in mock_modules.items():
            sys.modules[name] = mock_module
        
        try:
            container = configure_container(socketio=mock_socketio)
            
            # Verify container is configured
            assert isinstance(container, ServiceContainer)
            assert len(container.get_service_names()) > 0
            
            # Verify socketio is set as external dependency
            assert 'socketio' in container._instances
            assert container._instances['socketio'] is mock_socketio
            
        finally:
            # Clean up mocked modules
            for name in mock_modules:
                if name in sys.modules:
                    del sys.modules[name]
    
    def test_configure_container_with_config(self):
        """Test configure_container with application config"""
        config = {'DEBUG': True, 'SECRET_KEY': 'test-key'}
        
        # Mock the service modules
        import sys
        from unittest.mock import MagicMock
        
        mock_modules = {
            'src.room_manager': MagicMock(),
            'src.game_manager': MagicMock(),
            'src.content_manager': MagicMock(),
            'src.error_handler': MagicMock(),
            'src.services.session_service': MagicMock(),
            'src.services.broadcast_service': MagicMock(),
            'src.services.auto_game_flow_service': MagicMock(),
        }
        
        for name, mock_module in mock_modules.items():
            sys.modules[name] = mock_module
        
        try:
            container = configure_container(config=config)
            
            # Verify config is set
            assert container._config['DEBUG'] == True
            assert container._config['SECRET_KEY'] == 'test-key'
            
        finally:
            # Clean up mocked modules
            for name in mock_modules:
                if name in sys.modules:
                    del sys.modules[name]


if __name__ == '__main__':
    pytest.main([__file__])