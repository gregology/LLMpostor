"""
Network Resilience Tests
Tests for handling various network failure scenarios and connection issues.
"""

import pytest
import time
import threading
from unittest.mock import patch, MagicMock
from flask_socketio import SocketIOTestClient
from app import app, socketio, room_manager, session_service


class TestNetworkResilience:
    """Test network failure scenarios and connection handling"""
    
    def setup_method(self):
        """Set up test environment before each test."""
        # Clear any existing state
        room_manager._rooms.clear()
        session_service._player_sessions.clear()
    
    def teardown_method(self):
        """Clean up after each test."""
        # Clean up state
        room_manager._rooms.clear()
        session_service._player_sessions.clear()
    
    def create_test_client(self):
        """Create a Socket.IO test client"""
        return SocketIOTestClient(app, socketio)
    
    def join_room(self, client, room_id, player_name):
        """Helper to join a room"""
        client.emit('join_room', {
            'room_id': room_id,
            'player_name': player_name
        })
        
        # Get the response
        received = client.get_received()
        if received:
            response = received[0]
            if response['name'] == 'room_joined':
                return response['args'][0]
        
        return None
    
    def setup_game_environment(self):
        """Setup a game environment with players"""
        client1 = self.create_test_client()
        client2 = self.create_test_client()
        
        # Join players to room
        join_data1 = self.join_room(client1, "test-room", "Player1")
        join_data2 = self.join_room(client2, "test-room", "Player2")
        
        return {
            'client1': client1,
            'client2': client2,
            'room_id': "test-room",
            'player1_id': join_data1['player_id'] if join_data1 else None,
            'player2_id': join_data2['player_id'] if join_data2 else None
        }

    def test_connection_drop_during_response_phase(self):
        """Test handling of connection drop during response submission"""
        env = self.setup_game_environment()
        client1, client2 = env['client1'], env['client2']
        
        # Start round
        client1.emit('start_round')
        client1.get_received()  # Clear buffer
        client2.get_received()  # Clear buffer
        
        # Begin response submission
        response_text = "Test response from Player1"
        
        # Simulate connection drop just before submission
        original_emit = client1.emit
        def drop_connection_emit(event, data=None):
            if event == 'submit_response':
                # Simulate connection drop
                client1.disconnect()
                return False
            return original_emit(event, data)
        
        client1.emit = drop_connection_emit
        
        # Attempt to submit response
        result = client1.emit('submit_response', {'response': response_text})
        assert result is False
        
        # Verify game state is still consistent for other players
        client2.emit('get_room_state')
        state_response = client2.get_received()[0]
        
        assert state_response['name'] == 'room_state_updated'
        game_state = state_response['args'][0]['game_state']
        assert game_state['phase'] == 'responding'

    def test_reconnection_after_network_failure(self):
        """Test automatic reconnection after network failure"""
        env = self.setup_game_environment()
        client1 = env['client1']
        
        # Store original connection status
        original_connected = client1.connected
        
        # Simulate network failure
        client1.disconnect()
        assert not client1.connected
        
        # Simulate reconnection
        client1.connect()
        
        # Verify reconnection
        assert client1.connected
        
        # Test that game state can be retrieved after reconnection
        client1.emit('get_room_state')
        response = client1.get_received()[0]
        
        assert response['name'] == 'room_state_updated'
        assert 'game_state' in response['args'][0]

    def test_slow_network_timeout_handling(self, app, setup_game_environment):
        """Test handling of slow network conditions and timeouts"""
        env = setup_game_environment
        client1, client2 = env['client1'], env['client2']
        
        # Start round
        client1.emit('start_round')
        client1.get_received()
        client2.get_received()
        
        # Simulate slow network by adding delays to socket communication
        original_emit = client1.emit
        
        def slow_emit(event, data=None):
            if event == 'submit_response':
                # Simulate network delay
                time.sleep(2)  # 2 second delay
            return original_emit(event, data)
        
        client1.emit = slow_emit
        
        start_time = time.time()
        client1.emit('submit_response', {'response': 'Test response'})
        end_time = time.time()
        
        # Verify the delay occurred
        assert end_time - start_time >= 2
        
        # Verify response was still processed
        responses = client1.get_received()
        success_response = next((r for r in responses if r['name'] == 'response_submitted'), None)
        assert success_response is not None

    def test_concurrent_connection_failures(self, app):
        """Test handling multiple simultaneous connection failures"""
        # Create multiple clients
        clients = []
        for i in range(5):
            client = create_test_client(app)
            join_room(client, "stress-room", f"Player{i}")
            clients.append(client)
        
        # Start a game
        clients[0].emit('start_round')
        for client in clients:
            client.get_received()  # Clear buffers
        
        # Simulate simultaneous disconnections
        disconnect_threads = []
        for i, client in enumerate(clients[:3]):  # Disconnect first 3 clients
            def disconnect_client(c):
                c.disconnect()
            
            thread = threading.Thread(target=disconnect_client, args=(client,))
            disconnect_threads.append(thread)
        
        # Execute disconnections simultaneously
        for thread in disconnect_threads:
            thread.start()
        
        for thread in disconnect_threads:
            thread.join()
        
        # Verify remaining clients can still get room state
        clients[3].emit('get_room_state')
        response = clients[3].get_received()[0]
        
        assert response['name'] == 'room_state_updated'
        # Should have fewer connected players
        room_state = response['args'][0]
        assert room_state['connected_count'] <= 2

    def test_network_partition_recovery(self, app, setup_game_environment):
        """Test recovery from network partition scenarios"""
        env = setup_game_environment
        client1, client2 = env['client1'], env['client2']
        
        # Start round
        client1.emit('start_round')
        client1.get_received()
        client2.get_received()
        
        # Submit response before partition
        client1.emit('submit_response', {'response': 'Response before partition'})
        client1.get_received()
        
        # Simulate network partition (disconnect without proper cleanup)
        client1.disconnect()
        
        # Other client continues game
        client2.emit('submit_response', {'response': 'Response during partition'})
        client2.get_received()
        
        # Simulate client1 reconnection after partition heals
        client1.connect()
        
        # Rejoin room after reconnection
        join_room(client1, env['room_id'], "Player1")
        
        # Verify client can get current game state
        client1.emit('get_room_state')
        response = client1.get_received()[0]
        
        assert response['name'] == 'room_state_updated'
        game_state = response['args'][0]['game_state']
        # Should be in guessing phase since both responses were submitted
        assert game_state['phase'] == 'guessing'

    def test_message_loss_during_critical_operations(self, app, setup_game_environment):
        """Test handling of message loss during critical game operations"""
        env = setup_game_environment
        client1, client2 = env['client1'], env['client2']
        
        # Track emitted events
        emitted_events = []
        original_emit = client1.emit
        
        def tracking_emit(event, data=None):
            emitted_events.append((event, data))
            # Simulate message loss for start_round
            if event == 'start_round':
                return False  # Simulate message not sent
            return original_emit(event, data)
        
        client1.emit = tracking_emit
        
        # Attempt to start round (will be lost)
        result = client1.emit('start_round')
        assert result is False
        
        # Verify round didn't actually start
        client2.emit('get_room_state')
        response = client2.get_received()[0]
        game_state = response['args'][0]['game_state']
        assert game_state['phase'] == 'waiting'
        
        # Restore normal emission and retry
        client1.emit = original_emit
        client1.emit('start_round')
        
        # Verify round now starts
        client1.get_received()
        client2.emit('get_room_state')
        response = client2.get_received()[0]
        game_state = response['args'][0]['game_state']
        assert game_state['phase'] == 'responding'

    def test_connection_recovery_with_state_sync(self, app, setup_game_environment):
        """Test that reconnection properly syncs game state"""
        env = setup_game_environment
        client1, client2 = env['client1'], env['client2']
        
        # Start round and advance to guessing phase
        client1.emit('start_round')
        client1.get_received()
        client2.get_received()
        
        # Submit responses
        client1.emit('submit_response', {'response': 'Client1 response'})
        client2.emit('submit_response', {'response': 'Client2 response'})
        
        # Clear received messages
        client1.get_received()
        client2.get_received()
        
        # Disconnect client1 during guessing phase
        client1.disconnect()
        
        # Client2 submits guess while client1 is disconnected
        client2.emit('submit_guess', {'guess_index': 0})
        client2.get_received()
        
        # Reconnect client1
        client1.connect()
        join_room(client1, env['room_id'], "Player1")
        
        # Verify client1 gets current state (should be in results phase)
        client1.emit('get_room_state')
        response = client1.get_received()[0]
        
        game_state = response['args'][0]['game_state']
        assert game_state['phase'] == 'results'
        assert 'round_results' in game_state

    def test_high_latency_network_conditions(self, app, setup_game_environment):
        """Test game behavior under high latency network conditions"""
        env = setup_game_environment
        client1, client2 = env['client1'], env['client2']
        
        # Add latency to all client1 communications
        original_emit = client1.emit
        
        def latency_emit(event, data=None):
            # Simulate 1 second network latency
            time.sleep(1)
            return original_emit(event, data)
        
        client1.emit = latency_emit
        
        # Start round with latency
        start_time = time.time()
        client1.emit('start_round')
        
        # Verify latency affected the operation
        assert time.time() - start_time >= 1
        
        # Clear buffers
        client1.get_received()
        client2.get_received()
        
        # Submit response with latency
        start_time = time.time()
        client1.emit('submit_response', {'response': 'Latency test response'})
        
        # Verify latency affected submission
        assert time.time() - start_time >= 1
        
        # Verify response was still processed correctly
        responses = client1.get_received()
        success_response = next((r for r in responses if r['name'] == 'response_submitted'), None)
        assert success_response is not None

    def test_connection_stability_under_load(self, app):
        """Test connection stability under concurrent load"""
        # Create multiple clients rapidly
        clients = []
        
        # Rapid client creation
        for i in range(10):
            client = create_test_client(app)
            clients.append(client)
            
        # All clients join the same room rapidly
        room_id = "load-test-room"
        join_threads = []
        
        def rapid_join(client, player_name):
            try:
                join_room(client, room_id, player_name)
            except Exception as e:
                # Some joins may fail under load, which is expected
                pass
        
        for i, client in enumerate(clients):
            thread = threading.Thread(target=rapid_join, args=(client, f"Player{i}"))
            join_threads.append(thread)
            thread.start()
        
        # Wait for all join attempts
        for thread in join_threads:
            thread.join()
        
        # Count successful connections
        connected_count = 0
        for client in clients:
            if client.connected:
                try:
                    client.emit('get_room_state')
                    response = client.get_received()[0]
                    if response['name'] == 'room_state_updated':
                        connected_count += 1
                except:
                    pass
        
        # Should have some successful connections (exact number may vary due to race conditions)
        assert connected_count > 0
        
        # Cleanup
        for client in clients:
            try:
                client.disconnect()
            except:
                pass

    def test_websocket_fallback_mechanisms(self, app, setup_game_environment):
        """Test WebSocket to polling fallback behavior"""
        env = setup_game_environment
        client1 = env['client1']
        
        # Note: This test would require more complex socket.io setup to fully test transport fallback
        # For now, we test basic functionality under connection stress
        
        # Stress the connection with rapid events
        for i in range(10):
            client1.emit('get_room_state')
            # Small delay to prevent overwhelming
            time.sleep(0.1)
        
        # Verify client is still connected and responsive
        client1.emit('get_room_state')
        response = client1.get_received()
        
        # Should still get responses despite the stress
        assert len(response) > 0
        assert any(r['name'] == 'room_state_updated' for r in response)