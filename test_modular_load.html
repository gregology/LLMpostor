<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular JavaScript Load Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .test-result { margin: 10px 0; padding: 10px; border-radius: 4px; }
        .pass { background-color: #d4edda; color: #155724; }
        .fail { background-color: #f8d7da; color: #721c24; }
        .info { background-color: #d1ecf1; color: #0c5460; }
    </style>
</head>
<body>
    <h1>LLMposter Modular JavaScript Load Test</h1>
    <div id="test-results"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <script>
        // Mock window variables for testing
        window.roomId = "test-room";
        window.maxResponseLength = 500;
        
        const results = [];
        
        function addResult(test, passed, message) {
            const div = document.createElement('div');
            div.className = `test-result ${passed ? 'pass' : 'fail'}`;
            div.innerHTML = `<strong>${test}:</strong> ${message}`;
            document.getElementById('test-results').appendChild(div);
            
            results.push({ test, passed, message });
        }
        
        function addInfo(message) {
            const div = document.createElement('div');
            div.className = 'test-result info';
            div.innerHTML = `<strong>Info:</strong> ${message}`;
            document.getElementById('test-results').appendChild(div);
        }
        
        // Load modules in sequence and test
        async function runTest() {
            addInfo('Starting modular JavaScript load test...');
            
            try {
                // Test 1: Check if Socket.IO is available
                const socketIOAvailable = typeof io !== 'undefined';
                addResult('Socket.IO Loaded', socketIOAvailable, socketIOAvailable ? 'Socket.IO library is available' : 'Socket.IO library not found');
                
                // Load modules
                const baseUrl = '/static/js/modules/';
                const modules = [
                    'SocketManager.js',
                    'GameStateManager.js', 
                    'TimerManager.js',
                    'ToastManager.js',
                    'UIManager.js',
                    'EventManager.js',
                    'GameClient.js'
                ];
                
                // Test 2: Load all modules
                for (const module of modules) {
                    try {
                        await loadScript(baseUrl + module);
                        addResult(`Module: ${module}`, true, 'Loaded successfully');
                    } catch (error) {
                        addResult(`Module: ${module}`, false, `Failed to load: ${error.message}`);
                        return;
                    }
                }
                
                // Test 3: Check if classes are defined
                const classTests = [
                    { name: 'SocketManager', cls: SocketManager },
                    { name: 'GameStateManager', cls: GameStateManager },
                    { name: 'TimerManager', cls: TimerManager },
                    { name: 'ToastManager', cls: ToastManager },
                    { name: 'UIManager', cls: UIManager },
                    { name: 'EventManager', cls: EventManager },
                    { name: 'GameClient', cls: GameClient }
                ];
                
                for (const { name, cls } of classTests) {
                    const defined = typeof cls === 'function';
                    addResult(`Class: ${name}`, defined, defined ? 'Class is defined' : 'Class not found');
                }
                
                // Test 4: Try instantiating GameClient
                try {
                    // Mock DOM elements that UIManager expects
                    const mockElements = [
                        'connectionStatus', 'playerCount', 'playersList', 'roundsPlayed',
                        'waitingState', 'responseState', 'guessingState', 'resultsState',
                        'currentPrompt', 'targetModel', 'responseInput', 'charCount',
                        'submitResponseBtn', 'responseTimer', 'responseTimerBar', 'submissionCount',
                        'responsesList', 'guessingTimer', 'guessingTimerBar', 'guessingTargetModel',
                        'guessingCount', 'correctResponse', 'roundScoresList', 'nextRoundTimer',
                        'leaveRoomBtn', 'shareRoomBtn', 'startRoundBtn'
                    ];
                    
                    mockElements.forEach(id => {
                        if (!document.getElementById(id)) {
                            const div = document.createElement('div');
                            div.id = id;
                            div.style.display = 'none';
                            document.body.appendChild(div);
                        }
                    });
                    
                    // Don't actually instantiate to avoid connection attempts
                    addResult('GameClient Instantiation', true, 'Would be able to instantiate (skipped to avoid server connection)');
                    
                } catch (error) {
                    addResult('GameClient Instantiation', false, `Failed: ${error.message}`);
                }
                
                // Test 5: Check modular architecture structure
                if (typeof GameClient === 'function') {
                    const prototype = GameClient.prototype;
                    const methods = ['initialize', 'getGameState', 'isConnected', 'joinRoom', 'leaveRoom'];
                    
                    for (const method of methods) {
                        const hasMethod = typeof prototype[method] === 'function';
                        addResult(`GameClient.${method}`, hasMethod, hasMethod ? 'Method exists' : 'Method missing');
                    }
                }
                
                addInfo('Test completed!');
                
                // Summary
                const passed = results.filter(r => r.passed).length;
                const total = results.length;
                addInfo(`Summary: ${passed}/${total} tests passed`);
                
            } catch (error) {
                addResult('Test Execution', false, `Test failed: ${error.message}`);
            }
        }
        
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
        
        // Run test when page loads
        document.addEventListener('DOMContentLoaded', runTest);
    </script>
</body>
</html>